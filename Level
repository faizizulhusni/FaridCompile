using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;

namespace RelicEscape
{
    public class Level3 : BaseLevel
    {
        private List<Enemy> enemies;
        private List<InteractiveObject> objects;
        private List<ItemDrop> itemDrops;

        // Level 3 state
        private bool[] roomCleared = new bool[4];
        private bool passcodeSolved = false;
        private string playerPasscode = "";
        private const string correctPasscode = "314";
        private bool isEnteringPasscode = false;

        // Hint tiles map: 0 = none, otherwise contains the digit to draw (3,1,4)
        private int[,] hintMap;

        // Track enemy room assignments
        private Dictionary<Enemy, int> enemyRooms = new Dictionary<Enemy, int>();

        public Level3(GameLevelManager game, Player player, Random random) : base(game, player, random)
        {
        }

        protected override void InitializeMap()
        {
            MapWidth = 28;
            MapHeight = 15;
            map = new TileType[MapWidth, MapHeight];

            for (int x = 0; x < MapWidth; x++)
                for (int y = 0; y < MapHeight; y++)
                    map[x, y] = TileType.Stone;

            // Outer walls
            for (int x = 0; x < MapWidth; x++)
            {
                map[x, 0] = TileType.Tree;
                map[x, MapHeight - 1] = TileType.Tree;
            }
            for (int y = 0; y < MapHeight; y++)
            {
                map[0, y] = TileType.Tree;
                map[MapWidth - 1, y] = TileType.Tree;
            }

            // Gates between rooms (initially closed) - using custom blocking tiles
            for (int y = 1; y < MapHeight - 1; y++)
            {
                map[7, y] = TileType.Fence;   // Room 1 ? 2 (using Fence as gate)
                map[14, y] = TileType.Fence;  // Room 2 ? 3
                map[21, y] = TileType.Fence;  // Room 3 ? 4
            }
        }

        // Initializes hint tiles (one per room) with the digits requested:
        // Room1 -> 3, Room2 -> 1, Room3 -> 4.
        private void InitializeHints()
        {
            hintMap = new int[MapWidth, MapHeight];

            // Room 1 area (columns 1..6) - place above center
            int rx1 = 3, ry1 = 5;
            if (rx1 > 0 && rx1 < MapWidth && ry1 > 0 && ry1 < MapHeight)
                hintMap[rx1, ry1] = 3;

            // Room 2 area (columns 8..13) - place toward top
            int rx2 = 10, ry2 = 4;
            if (rx2 > 0 && rx2 < MapWidth && ry2 > 0 && ry2 < MapHeight)
                hintMap[rx2, ry2] = 1;

            // Room 3 area (columns 15..20) - place offset from center
            int rx3 = 17, ry3 = 9;
            if (rx3 > 0 && rx3 < MapWidth && ry3 > 0 && ry3 < MapHeight)
                hintMap[rx3, ry3] = 4;
        }

        protected override void InitializeEntities()
        {
            enemies = new List<Enemy>();
            objects = new List<InteractiveObject>();
            itemDrops = new List<ItemDrop>();

            InitializeHints();

            // Set player spawn position to leftmost room
            player.Position = new Vector2(tileSize * 2, tileSize * 7);

            // Simulate relics from previous levels
            if (!player.HasItem("Spiritvine Blade"))
            {
                player.AddToInventory("Spiritvine Blade");
            }
            if (player.Inventory.Count(i => i == "Scroll of Antimatter") < 2)
            {
                player.AddToInventory("Scroll of Antimatter");
                player.AddToInventory("Scroll of Antimatter");
            }

            // Room 0 (columns 1-6) - Skeleton enemies
            var enemy1 = new Enemy(new Vector2(tileSize * 3, tileSize * 6), EnemyType.Snake);
            var enemy2 = new Enemy(new Vector2(tileSize * 4, tileSize * 8), EnemyType.Snake);
            var enemy3 = new Enemy(new Vector2(tileSize * 5, tileSize * 7), EnemyType.Spider);
            
            enemies.Add(enemy1);
            enemies.Add(enemy2);
            enemies.Add(enemy3);
            
            enemyRooms[enemy1] = 0;
            enemyRooms[enemy2] = 0;
            enemyRooms[enemy3] = 0;

            // Room 1 (columns 8-13) - More challenging mix
            var enemy4 = new Enemy(new Vector2(tileSize * 10, tileSize * 6), EnemyType.Snake);
            var enemy5 = new Enemy(new Vector2(tileSize * 11, tileSize * 8), EnemyType.Snake);
            var enemy6 = new Enemy(new Vector2(tileSize * 9, tileSize * 7), EnemyType.Spider);
            var enemy7 = new Enemy(new Vector2(tileSize * 10, tileSize * 9), EnemyType.Spider);
            var enemy8 = new Enemy(new Vector2(tileSize * 11, tileSize * 5), EnemyType.Spider);
            
            enemies.Add(enemy4);
            enemies.Add(enemy5);
            enemies.Add(enemy6);
            enemies.Add(enemy7);
            enemies.Add(enemy8);
            
            enemyRooms[enemy4] = 1;
            enemyRooms[enemy5] = 1;
            enemyRooms[enemy6] = 1;
            enemyRooms[enemy7] = 1;
            enemyRooms[enemy8] = 1;

            // Room 2 (columns 15-20) - Mini-boss (Scorpion as SkeletonKnight)
            var enemy9 = new Enemy(new Vector2(tileSize * 17, tileSize * 7), EnemyType.Scorpion, true);
            enemies.Add(enemy9);
            enemyRooms[enemy9] = 2;

            // Room 3 (columns 22-26) - Final boss (another tough Scorpion)
            var enemy10 = new Enemy(new Vector2(tileSize * 24, tileSize * 7), EnemyType.Scorpion);
            enemies.Add(enemy10);
            enemyRooms[enemy10] = 3;

            // MamaZ object in final room
            objects.Add(new InteractiveObject(new Vector2(tileSize * 24, tileSize * 5), "MamaZ", 48, 48));
        }

        protected override bool IsBlockingTile(TileType tile, int x, int y)
        {
            // Include Fence as blocking tile for Level 3 gates
            return base.IsBlockingTile(tile, x, y) || tile == TileType.Fence;
        }

        public override void Update(float deltaTime, KeyboardState keyState, KeyboardState prevKeyState)
        {
            // Handle passcode input mode separately
            if (isEnteringPasscode)
            {
                HandlePasscodeInput(keyState, prevKeyState);
                return; // Don't update player movement while entering passcode
            }

            int previousHealth = player.Health;
            player.Update(deltaTime, keyState, prevKeyState);

            if (player.Health < previousHealth) game.TriggerDamageEffect();
            if (player.State == EntityState.Dead)
            {
                game.TriggerGameOver();
                return;
            }

            player.Position.X = MathHelper.Clamp(player.Position.X, tileSize, (MapWidth - 2) * tileSize);
            player.Position.Y = MathHelper.Clamp(player.Position.Y, tileSize, (MapHeight - 2) * tileSize);

            CheckTileCollisions();

            foreach (var enemy in enemies)
            {
                if (enemy.State != EntityState.Dead)
                {
                    int healthBefore = player.Health;
                    Vector2 prevEnemyPos = enemy.Position;

                    enemy.Update(deltaTime, player, random);

                    ResolveEnemyTileCollision(enemy, prevEnemyPos);

                    if (player.Health < healthBefore) game.TriggerDamageEffect();
                }
            }

            foreach (var item in itemDrops)
                item.Update(deltaTime);

            if (player.IsAttacking) CheckPlayerAttack();
            CheckItemPickups(keyState, prevKeyState);
            CheckObjectInteractions(keyState, prevKeyState);
            CheckRoomClear();
            CheckFinalGate(keyState, prevKeyState);
        }

        private void ResolveEnemyTileCollision(Enemy enemy, Vector2 prevPosition)
        {
            Rectangle enemyRect = new Rectangle((int)enemy.Position.X, (int)enemy.Position.Y, enemy.Bounds.Width, enemy.Bounds.Height);

            int left = Math.Max(0, enemyRect.Left / tileSize);
            int right = Math.Min(MapWidth - 1, enemyRect.Right / tileSize);
            int top = Math.Max(0, enemyRect.Top / tileSize);
            int bottom = Math.Min(MapHeight - 1, enemyRect.Bottom / tileSize);

            for (int tx = left; tx <= right; tx++)
            {
                for (int ty = top; ty <= bottom; ty++)
                {
                    if (tx < 0 || tx >= MapWidth || ty < 0 || ty >= MapHeight) continue;
                    TileType t = map[tx, ty];
                    if (t == TileType.Tree || t == TileType.Fence)
                    {
                        Rectangle tileRect = new Rectangle(tx * tileSize, ty * tileSize, tileSize, tileSize);
                        if (enemyRect.Intersects(tileRect))
                        {
                            enemy.Position = prevPosition;
                            enemy.Bounds = new Rectangle((int)enemy.Position.X, (int)enemy.Position.Y, enemy.Bounds.Width, enemy.Bounds.Height);
                            enemy.WanderTimer = 0f;
                            return;
                        }
                    }
                }
            }
        }

        private void CheckPlayerAttack()
        {
            if (player.HasDealtDamageThisAttack) return;

            foreach (var enemy in enemies)
            {
                if (enemy.State == EntityState.Dead) continue;

                float distance = Vector2.Distance(player.Position, enemy.Position);
                if (distance < player.AttackRange && player.IsAttacking)
                {
                    // **FIX 1: Use fixed damage instead of percentage-based**
                    int damage = 10; // Fixed damage for Level 3
                    enemy.TakeDamage(damage);
                    player.HasDealtDamageThisAttack = true;

                    // Drop Fiery Blade when mini-boss (SkeletonKnight) dies
                    if (enemy.State == EntityState.Dead && enemy.DropsKey)
                    {
                        itemDrops.Add(new ItemDrop(enemy.Position, "Fiery Blade"));
                        game.ShowMessage("Fiery Blade dropped! Press E to pick up.");
                    }
                }
            }
        }

        private void CheckItemPickups(KeyboardState keyState, KeyboardState prevKeyState)
        {
            bool ePressed = keyState.IsKeyDown(Keys.E) && prevKeyState.IsKeyUp(Keys.E);

            for (int i = itemDrops.Count - 1; i >= 0; i--)
            {
                var item = itemDrops[i];
                float distance = Vector2.Distance(player.Position, item.Position);

                if (distance < 50f && ePressed)
                {
                    if (item.ItemName == "Fiery Blade")
                    {
                        RelicItem blade = new RelicItem("Fiery Blade", Color.OrangeRed, 70);
                        player.EquipRelic(blade);
                        player.AddToInventory(item.ItemName);
                        game.ShowMessage("Fiery Blade equipped! Damage increased!");
                        itemDrops.RemoveAt(i);
                    }
                }
            }
        }

        private void CheckObjectInteractions(KeyboardState keyState, KeyboardState prevKeyState)
        {
            bool ePressed = keyState.IsKeyDown(Keys.E) && prevKeyState.IsKeyUp(Keys.E);

            foreach (var obj in objects)
            {
                float distance = Vector2.Distance(player.Position, obj.Position);

                if (obj.Type == "MamaZ" && distance < 60f && ePressed)
                {
                    // Check if all Room 3 enemies are dead
                    bool room3Cleared = enemies.Where(e => enemyRooms.ContainsKey(e) && enemyRooms[e] == 3)
                                               .All(e => e.State == EntityState.Dead);

                    if (!room3Cleared)
                    {
                        game.ShowMessage("Defeat the Final Boss first!");
                    }
                    else
                    {
                        int relicCount = player.GetItemCount("Spiritvine Blade") +
                                       player.GetItemCount("Scroll of Antimatter") +
                                       player.GetItemCount("Fiery Blade");

                        if (relicCount >= 3)
                        {
                            game.TransitionToCutscene("Thank you, hero! You saved me! The realm is safe once more!");
                        }
                        else
                        {
                            game.ShowMessage("You must collect 3 relics to rescue me!");
                        }
                    }
                }
            }
        }

        private void CheckRoomClear()
        {
            // Room 0: enemies in columns 1-6
            if (!roomCleared[0])
            {
                bool allDead = enemies.Where(e => enemyRooms.ContainsKey(e) && enemyRooms[e] == 0)
                                     .All(e => e.State == EntityState.Dead);
                if (allDead)
                {
                    roomCleared[0] = true;
                    for (int y = 7; y <= 8; y++) map[7, y] = TileType.Exit;
                    game.ShowMessage("Room 1 cleared! Gate to Room 2 opened.");
                }
            }

            // Room 1: enemies in columns 8-13
            if (!roomCleared[1])
            {
                bool allDead = enemies.Where(e => enemyRooms.ContainsKey(e) && enemyRooms[e] == 1)
                                     .All(e => e.State == EntityState.Dead);
                if (allDead)
                {
                    roomCleared[1] = true;
                    for (int y = 7; y <= 8; y++) map[14, y] = TileType.Exit;
                    game.ShowMessage("Room 2 cleared! Gate to Room 3 opened.");
                }
            }

            // Room 2: enemies in columns 15-20
            if (!roomCleared[2])
            {
                bool allDead = enemies.Where(e => enemyRooms.ContainsKey(e) && enemyRooms[e] == 2)
                                     .All(e => e.State == EntityState.Dead);
                if (allDead)
                {
                    roomCleared[2] = true;
                    int relicCount = player.GetItemCount("Spiritvine Blade") +
                                   player.GetItemCount("Scroll of Antimatter") +
                                   player.GetItemCount("Fiery Blade");

                    if (relicCount >= 3)
                    {
                        game.ShowMessage("Final gate unlocked! Approach to enter passcode.");
                    }
                    else
                    {
                        game.ShowMessage("You need 3 relics to unlock the final gate!");
                    }
                }
            }
        }

        private void CheckFinalGate(KeyboardState keyState, KeyboardState prevKeyState)
        {
            int relicCount = player.GetItemCount("Spiritvine Blade") +
                           player.GetItemCount("Scroll of Antimatter") +
                           player.GetItemCount("Fiery Blade");

            if (roomCleared[2] && relicCount >= 3 && !passcodeSolved)
            {
                Rectangle gateRect = new Rectangle(21 * tileSize, 7 * tileSize, tileSize, 2 * tileSize);
                if (player.Bounds.Intersects(gateRect))
                {
                    // Activate passcode input mode
                    if (!isEnteringPasscode)
                    {
                        isEnteringPasscode = true;
                        playerPasscode = "";
                        game.ShowMessage("Enter 3-digit passcode: [Hint: Check the numbers in each room]");
                    }
                }
            }
        }

        private void HandlePasscodeInput(KeyboardState keyState, KeyboardState prevKeyState)
        {
            var newlyPressed = keyState.GetPressedKeys().Except(prevKeyState.GetPressedKeys()).ToArray();

            // Allow digits
            if (playerPasscode.Length < 3)
            {
                foreach (var k in newlyPressed)
                {
                    if (k >= Keys.D0 && k <= Keys.D9)
                    {
                        playerPasscode += ((int)k - (int)Keys.D0).ToString();
                        break;
                    }
                    if (k >= Keys.NumPad0 && k <= Keys.NumPad9)
                    {
                        playerPasscode += ((int)k - (int)Keys.NumPad0).ToString();
                        break;
                    }
                }
            }

            // Backspace
            if (newlyPressed.Contains(Keys.Back) && playerPasscode.Length > 0)
            {
                playerPasscode = playerPasscode.Substring(0, playerPasscode.Length - 1);
            }

            // Submit with Enter
            if (newlyPressed.Contains(Keys.Enter) && playerPasscode.Length == 3)
            {
                if (playerPasscode == correctPasscode)
                {
                    passcodeSolved = true;
                    isEnteringPasscode = false;
                    game.ShowMessage("Correct! Gate unlocked!");
                    for (int y = 7; y <= 8; y++)
                        map[21, y] = TileType.Exit;
                }
                else
                {
                    game.ShowMessage("Wrong passcode! Try again.");
                    playerPasscode = "";
                }
            }

            // Cancel with Escape
            if (newlyPressed.Contains(Keys.Escape))
            {
                isEnteringPasscode = false;
                playerPasscode = "";
                game.ShowMessage("Passcode entry cancelled.");
            }
        }

        public override void Draw(SpriteBatch spriteBatch, LevelTextures textures)
        {
            DrawMap(spriteBatch, textures);
            DrawHints(spriteBatch, textures);
            DrawObjects(spriteBatch, textures);
            DrawItemDrops(spriteBatch, textures);
            DrawEnemies(spriteBatch, textures);
            DrawPlayer(spriteBatch, textures);
        }

        private void DrawHints(SpriteBatch spriteBatch, LevelTextures textures)
        {
            if (hintMap == null) return;

            for (int x = 0; x < MapWidth; x++)
            {
                for (int y = 0; y < MapHeight; y++)
                {
                    if (hintMap[x, y] > 0)
                    {
                        Rectangle tileRect = new Rectangle(x * tileSize, y * tileSize, tileSize, tileSize);
                        spriteBatch.Draw(textures.Pixel, tileRect, Color.CornflowerBlue);
                        DrawRect(spriteBatch, tileRect, Color.Black * 0.3f, 1, textures.Pixel);
                    }
                }
            }
        }

        private void DrawObjects(SpriteBatch spriteBatch, LevelTextures textures)
        {
            foreach (var obj in objects)
            {
                if (obj.Type == "MamaZ")
                {
                    spriteBatch.Draw(textures.Pixel, obj.Bounds, Color.Pink);
                    DrawRect(spriteBatch, obj.Bounds, Color.Black, 2, textures.Pixel);
                }
            }
        }

        private void DrawItemDrops(SpriteBatch spriteBatch, LevelTextures textures)
        {
            foreach (var item in itemDrops)
            {
                Rectangle glowRect = new Rectangle(item.Bounds.X - 4, item.Bounds.Y - 4, item.Bounds.Width + 8, item.Bounds.Height + 8);
                spriteBatch.Draw(textures.Pixel, glowRect, item.DisplayColor * 0.3f);

                Texture2D itemSprite = item.ItemName == "Fiery Blade" ? textures.Blade : null;

                if (itemSprite != null)
                {
                    spriteBatch.Draw(itemSprite, item.Bounds, Color.White);
                }
                else
                {
                    spriteBatch.Draw(textures.Pixel, item.Bounds, item.DisplayColor);
                }

                DrawRect(spriteBatch, item.Bounds, Color.White, 2, textures.Pixel);
            }
        }

        private void DrawEnemies(SpriteBatch spriteBatch, LevelTextures textures)
        {
            foreach (var enemy in enemies)
            {
                if (enemy.State == EntityState.Dead) continue;

                Rectangle enemyRect = new Rectangle((int)enemy.Position.X, (int)enemy.Position.Y, 32, 32);

                Texture2D enemyTex = enemy.Type switch
                {
                    EnemyType.Snake => textures.Snake,
                    EnemyType.Spider => textures.Spider,
                    EnemyType.Scorpion => textures.Scorpion,
                    _ => null
                };

                if (enemyTex != null)
                {
                    spriteBatch.Draw(enemyTex, enemyRect, null, Color.White, 0f, Vector2.Zero, enemy.FacingDirection, 0f);
                }
                else
                {
                    Color enemyColor = enemy.Type switch
                    {
                        EnemyType.Snake => Color.LimeGreen,
                        EnemyType.Spider => Color.DarkViolet,
                        EnemyType.Scorpion => Color.DarkRed,
                        _ => Color.Red
                    };
                    spriteBatch.Draw(textures.Pixel, enemyRect, enemyColor);
                    DrawRect(spriteBatch, enemyRect, Color.Black, 2, textures.Pixel);
                }

                float healthPercent = (float)enemy.Health / enemy.MaxHealth;
                Rectangle healthBar = new Rectangle((int)enemy.Position.X, (int)enemy.Position.Y - 8, (int)(32 * healthPercent), 4);
                spriteBatch.Draw(textures.Pixel, healthBar, Color.Red);
            }
        }

        public override void DrawUI(SpriteBatch spriteBatch, Texture2D pixelTexture, SpriteFont font, int screenWidth, int screenHeight)
        {
            Rectangle uiPanel = new Rectangle(10, 10, 400, 250);
            spriteBatch.Draw(pixelTexture, uiPanel, Color.Black * 0.7f);
            DrawRect(spriteBatch, uiPanel, Color.Gold, 2, pixelTexture);

            int yPos = 20;

            // Health bar
            Rectangle healthBarBg = new Rectangle(20, yPos, 250, 20);
            Rectangle healthBarFg = new Rectangle(20, yPos, (int)(250 * (player.Health / 100f)), 20);
            spriteBatch.Draw(pixelTexture, healthBarBg, Color.DarkRed);
            spriteBatch.Draw(pixelTexture, healthBarFg, Color.LimeGreen);
            DrawRect(spriteBatch, healthBarBg, Color.White, 2, pixelTexture);

            if (font != null)
            {
                spriteBatch.DrawString(font, $"HP: {player.Health}/100", new Vector2(25, yPos + 2), Color.White, 0f, Vector2.Zero, 0.6f, SpriteEffects.None, 0f);
                yPos += 35;

                int relicCount = player.GetItemCount("Spiritvine Blade") +
                               player.GetItemCount("Scroll of Antimatter") +
                               player.GetItemCount("Fiery Blade");

                spriteBatch.DrawString(font, $"Relics: {relicCount}/3", new Vector2(20, yPos), Color.Yellow, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                yPos += 25;

                spriteBatch.DrawString(font, $"Weapon: {player.CurrentWeapon.Name}", new Vector2(20, yPos), Color.White, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                yPos += 25;
                
                // **FIX 2: Show fixed damage instead of percentage**
                spriteBatch.DrawString(font, $"Damage: 10 (Fixed)", new Vector2(20, yPos), Color.Yellow, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                yPos += 35;

                // **FIX 3: Show passcode entry UI more prominently and in a separate panel**
                if (isEnteringPasscode)
                {
                    // Draw a centered overlay panel for passcode input
                    Rectangle passcodePanel = new Rectangle(
                        screenWidth / 2 - 250,
                        screenHeight / 2 - 100,
                        500,
                        200
                    );
                    
                    spriteBatch.Draw(pixelTexture, passcodePanel, Color.Black * 0.95f);
                    DrawRect(spriteBatch, passcodePanel, Color.Cyan, 3, pixelTexture);

                    int panelY = passcodePanel.Y + 20;
                    
                    spriteBatch.DrawString(font, "ENTER PASSCODE", 
                        new Vector2(passcodePanel.X + 120, panelY), 
                        Color.Cyan, 0f, Vector2.Zero, 1.0f, SpriteEffects.None, 0f);
                    panelY += 40;

                    spriteBatch.DrawString(font, "Hint: Check blue tiles in rooms", 
                        new Vector2(passcodePanel.X + 80, panelY), 
                        Color.LightGray, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                    panelY += 35;

                    string passcodeDisplay = playerPasscode.PadRight(3, '_');
                    spriteBatch.DrawString(font, $"CODE: {passcodeDisplay}", 
                        new Vector2(passcodePanel.X + 150, panelY), 
                        Color.Yellow, 0f, Vector2.Zero, 1.2f, SpriteEffects.None, 0f);
                    panelY += 45;

                    spriteBatch.DrawString(font, "Press ENTER to submit | BACKSPACE to delete", 
                        new Vector2(passcodePanel.X + 60, panelY), 
                        Color.LightGray, 0f, Vector2.Zero, 0.6f, SpriteEffects.None, 0f);
                    panelY += 25;
                    
                    spriteBatch.DrawString(font, "Press ESC to cancel", 
                        new Vector2(passcodePanel.X + 140, panelY), 
                        Color.LightGray, 0f, Vector2.Zero, 0.6f, SpriteEffects.None, 0f);
                }
                else if (roomCleared[2] && !passcodeSolved)
                {
                    // Show hint when player needs to approach gate
                    spriteBatch.DrawString(font, "Approach final gate", new Vector2(20, yPos), Color.Orange, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                    yPos += 20;
                    spriteBatch.DrawString(font, "to enter passcode", new Vector2(20, yPos), Color.Orange, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                }
            }
        }
    }
}